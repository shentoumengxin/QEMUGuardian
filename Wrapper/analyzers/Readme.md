## **Analyzer脚本功能与原理详解**

这套系统包含10个独立的分析器（Analyzer）脚本，每个脚本都设计用于检测一种或一类特定的安全风险或恶意行为。它们通过解析由bpftrace实时生成的系统调用日志，并应用不同的逻辑规则，最终实现对潜在威胁的识别和告警。

### **1\. AccessControl.py**

功能:  
检测与访问控制相关的安全风险，主要覆盖三种经典场景：权限提升、敏感文件访问和路径遍历攻击。  
**工作原理**:

* **权限提升 (Privilege Escalation)**: 监听SETUID, SETGID等系统调用事件。当脚本检测到有进程尝试将自己的用户ID（UID）或组ID（GID）设置为0（即root用户）时，会立即判定为高风险的权限提升行为。  
* **敏感文件访问 (Sensitive File Access)**: 监听TRACK\_OPENAT事件。脚本内部维护一个预定义的敏感文件列表（例如 /etc/shadow, /etc/passwd, /etc/sudoers）。如果一个程序尝试打开这个列表中的任何文件，脚本会认为这可能是在窃取凭证或关键配置，从而报警。  
* **路径遍历 (Path Traversal)**: 同样监听TRACK\_OPENAT事件。它会检查程序尝试打开的文件路径中是否包含../这样的序列。这种序列是路径遍历攻击的典型特征，其目的是为了跳出当前授权的目录，访问文件系统中的其他任意文件。

### **2\. CodeInjection.py**

功能:  
检测命令注入攻击的最终执行阶段。  
**工作原理**:

* 监听EXEC事件，该事件在进程执行一个新程序时触发。  
* 脚本内部维护一个“可疑命令”列表，主要包含各种常见的shell程序（如 /bin/sh, /bin/bash）。  
* 当EXEC事件发生时，脚本会检查被执行的程序名是否位于此列表中。如果是，则立即报警。这种检测非常有效，因为许多Web漏洞（如SQL注入、远程命令执行）被利用后，攻击者的最终目的往往就是获得一个交互式的系统shell。

### **3\. ForkBomb.py**

功能:  
检测“Fork炸弹”攻击，这是一种经典的拒绝服务（DoS）攻击，通过无限创建子进程来迅速耗尽系统的进程资源，导致系统崩溃或无法响应。  
**工作原理**:

* 这是一个\*\*有状态（Stateful）\*\*的分析器。  
* 它监听TRACK\_FORK事件，这个事件在每一次fork()或clone()系统调用成功时都会产生。  
* 脚本使用一个**时间窗口**（例如2秒）来统计fork调用的频率。它将收到的事件按时间戳分组，并持续计算每个时间窗口内的fork总数。  
* 如果某个时间窗口内的fork次数超过了预设的阈值（例如50次），脚本就会判定系统正在遭受Fork炸弹攻击，并发出警报。

### **4\. InformationLeakage.py**

功能:  
通过一种启发式规则，检测网络和文件I/O中潜在的信息泄露行为。  
**工作原理**:

* 这是一个\*\*有状态（Stateful）\*\*的分析器，其核心逻辑基于“小输入后有大输出”这一经典的可疑模式。  
* **网络场景**: 监听RECVFROM（接收数据）和SENDTO（发送数据）事件。它会使用一个队列来记录最近几次接收数据包的大小。当一个SENDTO事件发生时，它会检查其发送的数据量是否远大于（例如超过10倍）最近接收到的数据量。如果是，则可能意味着程序在收到一个简单的触发指令后，泄露了大量内部数据。  
* **文件场景**: 逻辑与网络场景完全相同，但监听的是READ和WRITE事件。如果一次WRITE操作写入的数据量远大于最近几次READ操作读取的数据量，也会被视为可疑的信息泄露行为。

### **5\. MemoryCorruption.py**

功能:  
检测与内存破坏相关的恶意行为，主要针对两个关键指标：运行时代码执行和堆喷射攻击的迹象。  
**工作原理**:

* **Shellcode执行**: 监听MPROTECT事件。mprotect系统调用可以改变内存区域的访问权限。当攻击者将恶意代码（Shellcode）注入到程序的内存后，该内存区域通常是不可执行的。为了运行Shellcode，攻击者必须调用mprotect将其权限修改为“可执行”（PROT\_EXEC）。因此，脚本一旦检测到任何将内存页权限设置为可执行的mprotect调用，就会立即报警。  
* **堆喷射迹象**: 监听MMAP\_SUM事件，这是一个由monitor.bt每秒聚合输出的统计事件。堆喷射是一种经典的漏洞利用技术，攻击者会在漏洞触发前，向进程的堆内存中“喷射”大量包含Shellcode的内存块，以增加命中概率。这通常会导致短时间内出现超大的mmap内存分配。脚本会检查MMAP\_SUM事件中的max\_pages字段，如果单次或总计分配的页数超过一个很高的阈值，则报警。

### **6\. RaceCondition.py**

功能:  
检测一种特定的竞争条件（Race Condition）攻击模式，该模式模仿了著名的“脏牛”（Dirty COW, CVE-2016-5195）漏洞的利用手法。  
**工作原理**:

* 这是一个\*\*有状态（Stateful）\*\*的分析器。  
* 脏牛漏洞的利用核心在于两个线程的竞争：一个线程反复使用madvise(MADV\_DONTNEED)系统调用，建议内核可以丢弃某个内存页的干净缓存；而另一个线程则趁机写入/proc/self/mem，在内核将只读内存映射的私有写时复制（Copy-on-Write）页写回之前，修改只读内存。  
* 脚本同时监听MADVISE和WRITE事件。  
* 它在同一个时间窗口内，分别统计madvise调用中advice参数为MADV\_DONTNEED的次数，以及向/proc/self/mem（尽管脚本中简化为任意WRITE）的写入次数。  
* 如果在一个时间窗口内，这两个操作的发生频率都超过了各自的阈值，脚本就判定可能发生了脏牛类的竞争条件攻击。

### **7\. ReverseShell.py**

功能:  
检测反向Shell的建立过程。反向Shell是攻击者在突破边界后，让受害主机主动连接攻击者服务器以建立控制通道的常用手段。  
**工作原理**:

* 这是一个\*\*有状态（Stateful）\*\*的分析器。  
* 建立一个反向Shell的典型步骤是：1. 连接到攻击者的服务器 (connect)；2. 将进程的标准输入、输出、错误流重定向到这个网络连接上 (dup2)。  
* 脚本监听CONNECT、DUP2和TRACK\_FORK事件。  
* 当一个进程触发CONNECT事件时，脚本会记录其PID，并标记为“已连接”。  
* 当任何一个被标记为“已连接”的进程触发DUP2事件，并且目标文件描述符是0, 1, 或 2（即标准输入/输出/错误）时，脚本就判定为反向Shell攻击并报警。

### **8\. FilelessExecution.py**

功能:  
检测“无文件执行”攻击。这是一种高级的躲避技术，恶意代码不写入磁盘（从而绕过基于文件的杀毒软件扫描），而是直接在内存中加载并运行。  
**工作原理**:

* 监听EXEC事件。  
* 一种常见的无文件执行技术是使用memfd\_create系统调用在内存中创建一个匿名的文件，然后通过/proc/self/fd/\<fd\_number\>这个特殊的虚拟路径来执行它。  
* 脚本会检查EXEC事件中的filename字段。如果被执行的文件路径匹配/proc/self/fd/...这种独特的模式，脚本就判定这很可能是一次无文件执行攻击。

### **9\. AbnormalSignalHandling.py**

功能:  
检测异常的信号处理行为，这通常是高级漏洞利用技术（如面向返回值的编程ROP链）中的一个环节。  
**工作原理**:

* 监听SIGNAL\_GENERATE事件。  
* 在正常的程序执行中，某些信号（如SIGSEGV \- 段错误, SIGILL \- 非法指令）几乎总是致命的，会导致程序立即崩溃。  
* 然而，在漏洞利用中，攻击者可能会精心构造数据，故意触发这类异常，并利用一个自定义的信号处理程序来劫持程序的控制流，使其跳转到攻击者准备好的恶意代码（Shellcode）上。  
* 脚本维护一个“可疑信号”列表。当一个进程为自己生成了这些通常是致命的信号时，脚本会报警。因为它暗示程序可能没有按预期崩溃，而是进入了一个非正常的、可能由攻击者控制的执行流程。

### **10\. Reconnaissance.py**

功能:  
检测恶意软件在执行主要攻击载荷之前进行的“环境侦察”活动。  
**工作原理**:

* 监听READLINKAT事件，该事件用于读取符号链接的目标。  
* 恶意软件在运行初期，通常需要探测它所处的环境，例如：获取自身可执行文件的绝对路径以便自我复制、获取当前工作目录以定位其他文件、或者读取内存布局信息以绕过ASLR等安全机制。  
* 脚本维护一个敏感的/proc文件系统符号链接列表（例如 /proc/self/exe, /proc/self/cwd, /proc/self/maps）。  
* 当一个进程尝试读取这些能暴露环境信息的符号链接时，脚本会将其判定为可疑的侦察行为并报警。这虽然本身不是一个漏洞，但却是恶意活动的一个强烈指标。

---

## **How to Run Tests**
- src 下是十个测试文件 , 分别对应一个 analyzer 脚本
- 执行形如  make access_control , make reverse_shell 即可编译源码并在 qemu-x86_64 中执行