#!/usr/bin/env bpftrace

BEGIN {
    printf("Dynamic QEMU-user monitor…\n");
}

// 1) 一看到第一个 QEMU-user 的 openat，就把它的 PID 加入监控
tracepoint:syscalls:sys_enter_openat
/ strncmp(comm, "qemu-", 5) == 0 /
{
    @monitored[pid] = 1;
    printf("TRACK OPENAT: pid=%d bin=%s file=%s\n",
           pid, comm, str(args->filename));
}

// 当被监控的进程产生任何子进程时（fork/clone/vfork 都会走这里）
tracepoint:sched:sched_process_fork
/ @monitored[args->parent_pid] /
{
    @monitored[args->child_pid] = 1;
    printf("TRACK FORK: parent=%d child=%d\n",
           args->parent_pid, args->child_pid);
}
// 3) execve 也要追踪——进程名会变，但 PID 在监控列表里
tracepoint:syscalls:sys_enter_execve
/ strncmp(comm, "qemu-", 5) == 0 && str(args->filename) == "/usr/bin/qemu-x86_64" /
{
    @monitored[pid] = 1;  // 将该进程标记为受监控的 QEMU-user 进程
    printf("TRACK QEMU: pid=%d bin=%s\n", pid, str(args->filename));
}

// 后面的所有探针都只对 @monitored 的 PID 生效

/// —— 在 read 探针里打印 buf —— 
tracepoint:syscalls:sys_enter_read
/ @monitored[pid] /
{
    printf("READ: pid=%d fd=%d buf=\"%s\"\n",
           pid, args->fd, str(args->buf));
}

/// —— 在 write 探针里打印 buf ——
tracepoint:syscalls:sys_enter_write
/ @monitored[pid] /
{
    printf("WRITE: pid=%d fd=%d buf=\"%s\"\n",
           pid, args->fd, str(args->buf));
}

tracepoint:syscalls:sys_enter_readlinkat
/ @monitored[pid] && str(args->pathname)=="/proc/self/cwd" /
{
    printf("READLINKAT pwd: pid=%d path=%s\n",
           pid, str(args->pathname));
}

tracepoint:syscalls:sys_enter_socket
/ @monitored[pid] /
{
    printf("SOCKET: pid=%d domain=%d type=%d\n",
           pid, args->family, args->type);
}

tracepoint:syscalls:sys_enter_connect
/ @monitored[pid] /
{
    printf("CONNECT: pid=%d addr=%s\n", pid, str(args->uservaddr));
}

tracepoint:syscalls:sys_enter_sendto
/ @monitored[pid] /
{
    printf("SENDTO: pid=%d len=%d\n", pid, args->len);
}

tracepoint:syscalls:sys_enter_recvfrom
/ @monitored[pid] /
{
    printf("RECVFROM: pid=%d size=%d\n", pid, args->size);
}

END {
    printf("Dynamic QEMU-user monitor stopped.\n");
}